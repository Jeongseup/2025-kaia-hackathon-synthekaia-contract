// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import "forge-std/Test.sol";
import "@openzeppelin/contracts/token/ERC20/ERC20.sol";
import "../src/HybridStrategyManager.sol";
import "../src/test/MockStKaia.sol";
import "../src/test/MockPerpDex.sol";
import "../src/test/MockKlaySwap.sol";

// A mock USDT token with a public mint function for testing purposes.
contract MockUSDT is ERC20 {
    constructor() ERC20("Mock USDT", "mUSDT") {}

    function mint(address to, uint256 amount) public {
        _mint(to, amount);
    }
}

contract HybridStrategyManagerTest is Test {
    // --- Contracts ---
    HybridStrategyManager public manager;
    MockStKaia public mockStKaia;
    MockPerpDex public mockPerpDex;
    MockKlaySwap public mockKlaySwap;
    MockUSDT public mockUsdt;

    // --- Users ---
    address public owner = makeAddr("owner");
    address public user = makeAddr("user");

    function setUp() public {
        // 1. Deploy all mock contracts
        mockStKaia = new MockStKaia();
        mockUsdt = new MockUSDT();
        mockPerpDex = new MockPerpDex(address(mockUsdt));
        mockKlaySwap = new MockKlaySwap(address(mockUsdt));

        // 2. Deploy the main strategy manager contract, injecting all mock addresses
        manager = new HybridStrategyManager(
            address(mockStKaia),
            address(mockPerpDex),
            address(mockKlaySwap),
            address(mockUsdt),
            owner
        );
    }

    function test_deposit_ExecutesBothStrategiesCorrectly() public {
        // --- Arrange ---
        uint256 totalDeposit = 100 ether;
        vm.deal(user, totalDeposit);

        uint256 expectedStakeAmount = totalDeposit / 2;
        uint256 expectedSwapAmount = totalDeposit - expectedStakeAmount;
        
        // Expected USDT from swap (1 KAIA = 0.3 USDT, 6 decimals)
        uint256 expectedUsdtReceived = (expectedSwapAmount * mockKlaySwap.KAIA_TO_USDT_RATE()) / 1 ether;

        // --- Act ---
        vm.prank(user);
        manager.deposit{value: totalDeposit}();

        // --- Assert ---
        // 1. General state checks
        assertEq(manager.totalKaiADeposited(), totalDeposit, "Total deposited KAIA should be tracked");
        assertEq(manager.userTotalDeposits(user), totalDeposit, "User's total deposit should be tracked");

        // 2. Staking strategy checks
        assertEq(mockStKaia.balanceOf(address(manager)), expectedStakeAmount, "Manager should hold correct stKAIA balance");
        assertEq(address(mockStKaia).balance, expectedStakeAmount, "MockStKaia should have received 50% of KAIA");

        // 3. Shorting strategy checks
        assertEq(address(mockKlaySwap).balance, expectedSwapAmount, "MockKlaySwap should have received 50% of KAIA");
        assertEq(mockUsdt.balanceOf(address(mockPerpDex)), expectedUsdtReceived, "MockPerpDex should hold the USDT margin");
        
        // Verify the data sent to open the position
        IPerpDex.OpenPositionData memory positionData = mockPerpDex.lastOpenPositionData();
        assertEq(uint(positionData.tokenType), uint(IPerpDex.TokenType.Btc), "Position should be for BTC");
        assertEq(positionData.marginAmount, expectedUsdtReceived, "Margin should match swapped USDT");
        assertEq(positionData.leverage, 3, "Leverage should be 3x");
        assertEq(positionData.long, false, "Position should be a short");
        assertEq(positionData.trader, address(manager), "Trader should be the manager contract");
    }
    
    function test_Fail_DepositZero() public {
        vm.expectRevert("Deposit must be > 0");
        vm.prank(user);
        manager.deposit{value: 0}();
    }
}



// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import "forge-std/Test.sol";
import "../src/KaiaStakingManager.sol";
// Import the standalone mock contract instead of defining it inline.
import "../src/test/MockStKaia.sol";

contract KaiaStakingManagerTest is Test {
    KaiaStakingManager public manager;
    MockStKaia public mockStKaia;

    address public owner = makeAddr("owner");
    address public user1 = makeAddr("user1");
    address public user2 = makeAddr("user2");

    function setUp() public {
        // Step 1: Deploy the mock stKAIA contract first.
        mockStKaia = new MockStKaia();

        // Step 2: Deploy the KaiaStakingManager, injecting the mock's address.
        // This simulates a real-world scenario where the stKAIA address is known at deployment.
        manager = new KaiaStakingManager(address(mockStKaia), owner);
    }

    function test_InitialState() public {
        assertEq(manager.owner(), owner);
        assertEq(address(manager.ST_KAIA()), address(mockStKaia));
        assertEq(manager.totalKaiADeposited(), 0);
    }

    function test_Deposit_SingleUser() public {
        // Arrange
        uint256 depositAmount = 10 ether;
        vm.deal(user1, depositAmount);

        // Act
        vm.prank(user1);
        manager.deposit{value: depositAmount}();

        // Assert
        assertEq(manager.totalKaiADeposited(), depositAmount, "Total deposited should be updated");
        assertEq(manager.getKaiaDepositedByUser(user1), depositAmount, "User's deposit should be recorded");
        assertEq(manager.getContractStKaiaBalance(), depositAmount, "Contract should receive stKAIA");
        assertEq(address(mockStKaia).balance, depositAmount, "Mock should receive KAIA");
    }

    function test_Deposit_MultipleUsers() public {
        // Arrange
        uint256 amount1 = 10 ether;
        uint256 amount2 = 25 ether;
        vm.deal(user1, amount1);
        vm.deal(user2, amount2);

        // Act
        vm.prank(user1);
        manager.deposit{value: amount1}();
        vm.prank(user2);
        manager.deposit{value: amount2}();
        
        // Assert
        assertEq(manager.totalKaiADeposited(), amount1 + amount2);
        assertEq(manager.getKaiaDepositedByUser(user1), amount1);
        assertEq(manager.getKaiaDepositedByUser(user2), amount2);
        assertEq(manager.getContractStKaiaBalance(), amount1 + amount2);
    }

    function test_Fail_DepositZero() public {
        vm.expectRevert("Deposit amount must be positive");
        vm.prank(user1);
        manager.deposit{value: 0}();
    }

    function test_WithdrawStKaia_Success() public {
        // Arrange: User1 deposits first
        uint256 depositAmount = 50 ether;
        vm.deal(user1, depositAmount);
        vm.prank(user1);
        manager.deposit{value: depositAmount}();

        // Act: Owner withdraws a portion
        uint256 withdrawAmount = 20 ether;
        vm.prank(owner);
        manager.withdrawStKaia(withdrawAmount, owner);

        // Assert
        assertEq(manager.getContractStKaiaBalance(), depositAmount - withdrawAmount, "Contract balance should decrease");
        assertEq(mockStKaia.balanceOf(owner), withdrawAmount, "Owner should receive stKAIA");
    }
    
    function test_Fail_WithdrawStKaia_NotOwner() public {
        // Arrange
        vm.deal(user1, 10 ether);
        vm.prank(user1);
        manager.deposit{value: 10 ether}();

        // Act & Assert
        vm.expectRevert(abi.encodeWithSelector(manager.NotOwner.selector));
        vm.prank(user1);
        manager.withdrawStKaia(5 ether, user1);
    }
    
    function test_Fail_WithdrawStKaia_InsufficientBalance() public {
        // Arrange
        vm.deal(user1, 10 ether);
        vm.prank(user1);
        manager.deposit{value: 10 ether}();

        // Act & Assert
        vm.expectRevert("Invalid or insufficient amount");
        vm.prank(owner);
        manager.withdrawStKaia(11 ether, owner);
    }
}

