// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import "@openzeppelin/contracts/access/Ownable.sol";
import "@openzeppelin/contracts/security/ReentrancyGuard.sol";
import "./interfaces/IStKaia.sol";

/**
 * @title KaiaStakingManager
 * @author [Your Name/Team]
 * @notice A robust contract for depositing KAIA into the stKAIA liquid staking protocol.
 * This contract acts as a wrapper, holding the resulting stKAIA tokens and tracking deposits.
 * It is built with security and clarity in mind, using OpenZeppelin standards.
 */
contract KaiaStakingManager is Ownable, ReentrancyGuard {
    /// @notice The immutable address of the stKAIA contract.
    IStKaia public immutable ST_KAIA;

    /// @notice Tracks the total amount of KAIA deposited by each user.
    mapping(address => uint256) public userDeposits;

    /// @notice The total amount of KAIA ever deposited into this contract.
    uint256 public totalKaiADeposited;

    /// @notice Emitted when a user successfully deposits KAIA.
    event Deposited(address indexed user, uint256 kaiaAmount);

    /// @notice Emitted when the owner withdraws stKAIA from the contract.
    event StKaiaWithdrawn(address indexed to, uint256 stKaiaAmount);

    /**
     * @notice Contract constructor.
     * @param _stKaiaAddress The address of the stKAIA protocol contract.
     * @param _initialOwner The address that will become the owner of this contract.
     */
    constructor(address _stKaiaAddress, address _initialOwner) Ownable(_initialOwner) {
        require(_stKaiaAddress != address(0), "StKaia address cannot be zero");
        ST_KAIA = IStKaia(_stKaiaAddress);
    }

    /**
     * @notice Accepts KAIA deposits from users, stakes them into the stKAIA contract,
     * and updates the deposit records.
     * @dev The stKAIA tokens are held by this contract (`address(this)`).
     * This function is nonReentrant to prevent re-entrancy attacks.
     */
    function deposit() external payable nonReentrant {
        uint256 depositAmount = msg.value;
        require(depositAmount > 0, "Deposit amount must be positive");

        // Update state variables before the external call (Checks-Effects-Interactions pattern)
        userDeposits[msg.sender] += depositAmount;
        totalKaiADeposited += depositAmount;

        // Stake the KAIA into the stKAIA contract, which will mint stKAIA to this contract
        ST_KAIA.stakeFor{value: depositAmount}(address(this));

        emit Deposited(msg.sender, depositAmount);
    }

    /**
     * @notice Allows the owner to withdraw a specified amount of stKAIA tokens
     * from this contract to a designated address.
     * @param _amount The amount of stKAIA to withdraw.
     * @param _to The recipient address for the stKAIA tokens.
     */
    function withdrawStKaia(uint256 _amount, address _to) external onlyOwner {
        require(_to != address(0), "Cannot withdraw to the zero address");
        
        uint256 currentBalance = ST_KAIA.balanceOf(address(this));
        require(_amount > 0 && _amount <= currentBalance, "Invalid or insufficient amount");

        bool success = ST_KAIA.transfer(_to, _amount);
        require(success, "stKAIA transfer failed");

        emit StKaiaWithdrawn(_to, _amount);
    }

    /**
     * @notice A view function to get the total KAIA deposited by a specific user.
     * @param _user The address of the user to query.
     * @return The total KAIA deposited by the user.
     */
    function getKaiaDepositedByUser(address _user) external view returns (uint256) {
        return userDeposits[_user];
    }

    /**
     * @notice A view function to get the current stKAIA balance of this contract.
     * @return The contract's stKAIA balance.
     */
    function getContractStKaiaBalance() external view returns (uint256) {
        return ST_KAIA.balanceOf(address(this));
    }
}
